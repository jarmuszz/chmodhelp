#!/bin/bash

function print_help {
#################
# help function #
#################
  #
  # prints help and then exits
  #
  if [[ -z $1 ]]; then
    echo "Usage: chmodhelp [NUMERIC NOTATION]"
    echo "       chmodhelp [SYMBOLIC NOTATION]"
    echo "       chmodhelp [OPTION]"
    echo ""
    echo "Prints chmod table corresponding to NUMERIC NOTATION or SYMBOLIC NOTATION."
    echo ""
    echo "Options: {-h, --help}     Displays this message"
    echo "         {-d, --demo}     Prints demo table"
    echo ""
    echo "Examples:"
    echo "       chmodhelp"
    echo "       chmodhelp 755"
    echo "       chmodhelp rwxr-xr-x"
    echo "       chmodhelp -h"
    echo "       chmodhelp --demo"
    echo ""
    echo "Version: 1.2"
    echo 'All bugs report to: https://github.com/jarmuszz/chmodhelp'
    exit 1
  else
    echo -e "chmodhelp \e[91mError\e[0m:"
    echo -e "    \e[1m${1}\e[0m"
    echo -e "Type \e[97mchmodhelp -h \e[0mfor help"
    exit 1
  fi
}

function check_options {
###########################
# checks options and runs #
#  coresponding commands  #
###########################
  #
  #
  # OPTIONS array contains avaible
  # options. ACTIONS table contains
  # coresponding commands.
  # e.g:
  #   OPTIONS[0] -> '-h'
  #   ACTIONS[0] -> 'print_help'
  OPTIONS=('-h' '--help' '-d' '--demo')
  #
  ACTIONS=("print_help" "print_help" 
           "demo_table" "demo_table")
  #
  #
  # This loop checks every iteration
  # if argument is in OPTIONS array,
  # if it is, then coresponding command  
  # form ACTIONS array is executed.
  for ((i=0; i<=${#OPTIONS[*]}; i++)) {
    if [[ $1 = "${OPTIONS[$i]}" ]]; then
      ${ACTIONS[$i]}
      exit 0
  fi
  }
  #
  # Function returns -1 when argument
  # is not in OPTIONS array.
  print_help "Invalid Option: \"$1\""
}

function num_to_text {
  for ((i=1; i<=3; i++)); do
  #########################################
  # converts numeric to symbolic notation #
  #########################################
    #
    # cuts number every iteration
    # e.g. 755:
    #   1st iteration: 7
    #   2nd iteration: 5
    #   3rd iteration: 5
    num=$(echo $1|cut -b${i})
    #
    # checking every number is faster than calculations
    case $num in
      7) echo -n "rwx" ;;
      6) echo -n "rw-" ;;
      5) echo -n "r-x" ;;
      4) echo -n "r--" ;;
      3) echo -n "-wx" ;;
      2) echo -n "-w-" ;;
      1) echo -n "--x" ;;
      0) echo -n "---" ;;
    esac
  done
}

function text_to_num {
    #
    # init of the array
    a=()
    

    for ((i=0; i<3; i++)) {
    #########################################
    # converts symbolic to numeric notation #
    #########################################
      #
      # start of the segment
      s=$(( $i * 3 + 1 ))
      #
      # end of the segment
      e=$(( $s + 2 ))
      #
      # checking every combination is
      # faster than the calculations
      case $(echo -n $1 | cut -b${s}-${e}) in
        "rwx") a+="7" ;;
        "rw-") a+="6" ;;
        "r-x") a+="5" ;;
        "r--") a+="4" ;;
        "-wx") a+="3" ;;
        "-w-") a+="2" ;;
        "--x") a+="1" ;;
        "---") a+="0" ;;
        # 
        # function returns -1
        # when format is invalid
        *)     echo "-1" 
               exit 1 ;;
      esac
    }
  echo $a
}

function draw_table {
  #
  # init of the array
  a=()
  #
  # init of num variable
  num=0
  

  if [[ ! -z $2 ]]; then
  ######################################
  # runs when first argument is a text #
  ######################################
    #
    # num -> numeric notation
    num=$(text_to_num $1)
    #
    # text_to_num returns -1 when format is incorrect
    [[ $num -eq -1 ]] && print_help "Invalid Symbolic Notation: $1"
    #
    # o -> symbolic notation
    o=$1


  else
  ########################################
  # runs when first argument is a number #
  ########################################
    #
    #
    # is number lower than 777 
    # (maximal number of numeric notation)
    [[ $1 -gt 777 ]] && print_help "Invalid Numeric Notation: $1"
    #
    # translate numeric to symbolic notation
    # o -> numeric notation
    o=$(num_to_text $1)
    #
    # num -> symbolic notation
    num=$o
  fi
 

  for ((i=1; i<=${#o}; i++)) {
  #####################
  # colorizing output #
  #####################
    #
    #
    p=$(echo $o | cut -b${i})
    case $p in
      #
      # red
      "r") a[i-1]="\e[31m${p}\e[39m" ;;
      #
      # green
      "w") a[i-1]="\e[32m${p}\e[39m" ;;
      #
      # blue
      "x") a[i-1]="\e[34m${p}\e[39m" ;;
      #
      # default color
      "-") a[i-1]="-" ;;
      *)
    esac
  }
  
##################
# printing table #
##################
  # 
  echo -en  '\e[39m'
  echo -e  '    +---+---+---+'
  echo -e  '    | r | w | x |'
  echo -e  '+---+---+---+---+'
  echo -e  "| O | ${a[0]} | ${a[1]} | ${a[2]} |" 
  echo -e  '+---+---+---+---+'
  echo -e  "| G | ${a[3]} | ${a[4]} | ${a[5]} |" 
  echo -e  '+---+---+---+---+'
  echo -e  "| E | ${a[6]} | ${a[7]} | ${a[8]} |" 
  echo -e  '+---+---+---+---+'
  echo -e  "${1} -> ${num}"
}

function demo_table {
  ##############
  # demo table #
  ##############
  #
  echo -en  '\e[39m'
  echo -e  '           +------+-------+---------+'
  echo -e  '           | read | write | execute |'
  echo -e  '+----------+------+-------+---------+'
  echo -e  "| Owner    | 400  |  200  |   100   |" 
  echo -e  '+----------+------+-------+---------+'
  echo -e  "| Group    | 040  |  020  |   010   |" 
  echo -e  '+----------+------+-------+---------+'
  echo -e  "| Everyone | 004  |  002  |   001   |" 
  echo -e  '+----------+------+-------+---------+'
}


######################
# checking arguments #
######################
  #
  #
if [[ -z $1 ]]; then
  #
  # runs when no argument is passed
  print_help
  #
elif [ $1 -eq $1 2>/dev/null ]; then
##################################
# runs when argument is a number #
##################################
  #
  # Arguments are not mutable,
  # so we create var that holds
  # value of the first argument.
  arg=$1
  #
  # User may input number with dash
  # at the beginning, if it's the
  # case, then we cut the dash here.
  [ $arg -lt 0 ] &&
    arg=$(echo $arg | cut -b2-)
  #
  # Valid numeric notation is 3 digits
  # long. If argument is shorter, then
  # it's invalid.
  [ ${#arg} = 3 ]   &&
    draw_table $arg ||
    print_help "Invalid Numeric Notation: \"$1\"
    Number must be 3 digits long"
  #
  #
elif [[ ${#1} = 9 ]]; then
  #
  # runs when lenght of argument is 9 (lenght of symbolic notation)
  draw_table $1 1
  #
else
  #
  # runs when argument doesnt mach any of above
  check_options $1
  #
fi
