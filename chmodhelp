#!/usr/bin/env bash

function print_help {
#################
# help function #
#################
  #
  # prints help and then exits
  #
  if [[ -z $1 ]]; then
    echo "Usage: chmodhelp [NUMERIC NOTATION]"
    echo "       chmodhelp [SYMBOLIC NOTATION]"
    echo "       chmodhelp [OPTION]"
    echo ""
    echo "Prints chmod table corresponding to NUMERIC NOTATION or SYMBOLIC NOTATION."
    echo ""
    echo "Options: -h, --help           Displays this message"
    echo "         -d, --demo           Prints demo table"
    echo "         -i, --interactive    Interactive mode, see Interactive Mode for more help"
    echo ""
    echo "Interactive Mode:"
    echo "    Typing position of cell will fill/empty it. Cell's Positions"
    echo "    are made up of cell's class ((O)wner, (G)roup, (E)veryone)"
    echo "    and cell's permission ((R)ead, (W)rite, E(X)ecute)."
    echo ""
    echo "    E.g. Valid Position for cell representing (O)wner's right"
    echo "    to e(X)ecute is \"ox\" or \"xo\"."
    echo ""
    echo "    Upper and lowercase letters are treated as the same."
    echo "    On the bottom of the table, Numeric and Symbolic Notation are shown."
    echo "    Ctrl-C will exit program."
    echo ""
    echo "Examples:"
    echo "       chmodhelp"
    echo "       chmodhelp 755"
    echo "       chmodhelp rwxr-xr-x"
    echo "       chmodhelp -h"
    echo "       chmodhelp --demo"
    echo ""
    echo "Version: 1.3"
    echo 'All bugs report to: https://github.com/jarmuszz/chmodhelp'
    exit 1
  else
    echo -e "chmodhelp \e[91mError\e[0m:"
    echo -e "    \e[1m${1}\e[0m"
    echo -e "Type \e[97mchmodhelp -h \e[0mfor help"
    exit 1
  fi
}

function check_options {
###########################
# checks options and runs #
#  coresponding commands  #
###########################
  #
  #
  # OPTIONS array contains avaible
  # options. ACTIONS table contains
  # coresponding commands.
  # e.g:
  #   OPTIONS[0] -> '-h'
  #   ACTIONS[0] -> 'print_help'
  OPTIONS=('-h' '--help' '-d' '--demo' '-i' '--interactive')
  #
  ACTIONS=("print_help" "print_help" 
           "demo_table" "demo_table"
           "interactive" "interactive")
  #
  #
  # This loop checks every iteration
  # if argument is in OPTIONS array,
  # if it is, then coresponding command  
  # form ACTIONS array is executed.
  for ((i=0; i<=${#OPTIONS[*]}; i++)) {
    if [[ $1 = "${OPTIONS[$i]}" ]]; then
      ${ACTIONS[$i]}
      exit 0
  fi
  }
  #
  # If argument is invalid, then
  # error message is printed
  print_help "Invalid Option: \"$1\""
}

function num_to_text {
  for ((i=1; i<=3; i++)); do
  #########################################
  # converts numeric to symbolic notation #
  #########################################
    #
    # cuts number every iteration
    # e.g. 755:
    #   1st iteration: 7
    #   2nd iteration: 5
    #   3rd iteration: 5
    num=$(echo $1|cut -b${i})
    #
    # checking every number is faster than calculations
    case $num in
      7) echo -n "rwx" ;;
      6) echo -n "rw-" ;;
      5) echo -n "r-x" ;;
      4) echo -n "r--" ;;
      3) echo -n "-wx" ;;
      2) echo -n "-w-" ;;
      1) echo -n "--x" ;;
      0) echo -n "---" ;;
    esac
  done
}

function text_to_num {
    #
    # init of the array
    a=()
    

    for ((i=0; i<3; i++)) {
    #########################################
    # converts symbolic to numeric notation #
    #########################################
      #
      # start of the segment
      s=$(( $i * 3 + 1 ))
      #
      # end of the segment
      e=$(( $s + 2 ))
      #
      # checking every combination is
      # faster than the calculations
      case $(echo -n $1 | cut -b${s}-${e}) in
        "rwx") a+="7" ;;
        "rw-") a+="6" ;;
        "r-x") a+="5" ;;
        "r--") a+="4" ;;
        "-wx") a+="3" ;;
        "-w-") a+="2" ;;
        "--x") a+="1" ;;
        "---") a+="0" ;;
        # 
        # function returns -1
        # when format is invalid
        *)     echo "-1" 
               exit 1 ;;
      esac
    }
  echo $a
}

function draw_table {
  #
  # init of the array
  a=()
  #
  # init of num variable
  num=0
  

  if [[ ! -z $2 ]]; then
  ######################################
  # runs when first argument is a text #
  ######################################
    #
    # num -> numeric notation
    num=$(text_to_num $1)
    #
    # text_to_num returns -1 when format is incorrect
    [[ $num -eq -1 ]] && print_help "Invalid Symbolic Notation: $1"
    #
    # o -> symbolic notation
    o=$1


  else
  ########################################
  # runs when first argument is a number #
  ########################################
    #
    #
    # is number lower than 777 
    # (maximal number of numeric notation)
    [[ $1 -gt 777 ]] && print_help "Invalid Numeric Notation: $1"
    #
    # translate numeric to symbolic notation
    # o -> numeric notation
    o=$(num_to_text $1)
    #
    # num -> symbolic notation
    num=$o
  fi
 

  for ((i=1; i<=${#o}; i++)) {
  #####################
  # colorizing output #
  #####################
    #
    #
    p=$(echo $o | cut -b${i})
    case $p in
      #
      # red
      "r") a[i-1]="\e[31m${p}\e[39m" ;;
      #
      # green
      "w") a[i-1]="\e[32m${p}\e[39m" ;;
      #
      # blue
      "x") a[i-1]="\e[34m${p}\e[39m" ;;
      #
      # default color
      "-") a[i-1]="-" ;;
      *)
    esac
  }
  
##################
# printing table #
##################
  # 
  echo -en  '\e[39m'
  echo -e  '    +---+---+---+'
  echo -e  '    | r | w | x |'
  echo -e  '+---+---+---+---+'
  echo -e  "| O | ${a[0]} | ${a[1]} | ${a[2]} |" 
  echo -e  '+---+---+---+---+'
  echo -e  "| G | ${a[3]} | ${a[4]} | ${a[5]} |" 
  echo -e  '+---+---+---+---+'
  echo -e  "| E | ${a[6]} | ${a[7]} | ${a[8]} |" 
  echo -e  '+---+---+---+---+'
  echo -e  "${1} -> ${num}"
}

function interactive {
####################
# Interactive mode #
####################
  #
  # nn => Numeric Notation variable
  nn=000
  #
  # r => row variable
  r=0
  #
  # c => column variable
  c=0
  #
  # valid => is user input valid
  valid=1
  #
  # a => array filling the table
  a=()
  #
  # Loop that fills array a with 
  # spaces. This way table does 
  # not break when field is empty.
  for ((i=1; i<=9; i++)) {
    a[i]=' '
  }
  case ${#n} in
    1) n='00'${n} ;;
    2) n='0'${n} ;;
  esac
  #
  #
  while true; do
  #############
  # Main Loop #
  #############
    #
    # drawing table
    clear
    echo -en  '\e[39m'
    echo -e  '    +---+---+---+'
    echo -e  '    | \e[31mr\e[0m | \e[31mw\e[0m | \e[31mx\e[0m |'
    echo -e  '+---+---+---+---+'
    echo -e  "| \e[32mO\e[0m | ${a[1]} | ${a[2]} | ${a[3]} |" 
    echo -e  '+---+---+---+---+'
    echo -e  "| \e[32mG\e[0m | ${a[4]} | ${a[5]} | ${a[6]} |"  
    echo -e  '+---+---+---+---+'
    echo -e  "| \e[32mE\e[0m | ${a[7]} | ${a[8]} | ${a[9]} |" 
    echo -e  '+---+---+---+---+'
    #
    # Prints numeric and symbolic notation.
    nn=$(printf %03d $nn)
    #printf %03d $nn
    echo "$nn => $(num_to_text $nn)"
    #
    echo "Ctrl-C to exit"
    #
    # When given field is invalid
    # additional message is printed.
    if [[ $valid = 0 ]]; then
      echo "Invalid field \"$u\"";
      valid=1
    fi
    #
    # reads user input
    # u => holds user input
    echo -n ":"
    read u
    #
    #
    # The '^^' after u variable makes 
    # it upercase, this way lower and
    # upercase are treated as the same.
    #
    # Note: "not reversed" means that
    # permission char is the first one
    # in the input.
    #
    case $(echo ${u^^} | cut -b1) in
      # This part reverses input back
      # if user typed it in reverse.
      # e.g. xo => ox
      #
      # If 1st char of user input is
      # r, w or x, that means user
      # typed position reversed.
      #
      # ${u^^} makes $u upercase
      # "rev" command reverses input.
      'R' | 'W' | 'X') u=$(echo ${u^^} | rev) ;;
      #
      # If input is not reversed, then
      # we only make $u variable uppercase.
      *) u=${u^^} ;;
    esac
    #
    #
    case $(echo $u | cut -b1) in
      # Checks rows and sets
      # corresponding variables.
      # r => row variable
      # mult => numeric notation multiplayer
      #
      'O') r=0 
           mult=100
           ;;
      'G') r=3 
           mult=10
           ;;
      'E') r=6
           mult=1
           ;;
        #
        # runs when field is invalid
      *)  valid=0 ;;
    esac
    #
    # c => columns
    c=$(echo $u | cut -b2)
    #
    case $c in 
      # The same as above case
      # statement, but
      # checks columns
      # instead of rows.
      #
      # bn => base number
      'R') bn=4
           c=1
           ;;
      'W') bn=2
           c=2
           ;;
      'X') bn=1
           c=3
           ;;
      #
      # runs when output is invalid
      *) valid=0 ;;
    esac
    #
    #
    if [[ $valid = 1 ]]; then
    ################################
    # calculating Numeric Notation # 
    ################################
      #
      # cn => cell number
      cn=$(( $r + $c ))
      #
      # runs when cell is empty
      if [[ a[$cn] -eq ' ' ]]; then
        #
        # fills cell
        a[$cn]='*'
        # updates Numeric Notation
        nn=$(( $bn * $mult + $nn ))
        
      # runs when cell is filled
      else
        #
        # clears cell
        a[$cn]=' '
        #
        # updates Numeric Notation
        nn=$(( $nn - $bn * $mult ))
      fi
    fi
  done
}

function demo_table {
  ##############
  # demo table #
  ##############
  #
  echo -en  '\e[39m'
  echo -e  '           +------+-------+---------+'
  echo -e  '           | read | write | execute |'
  echo -e  '+----------+------+-------+---------+'
  echo -e  "| Owner    | 400  |  200  |   100   |" 
  echo -e  '+----------+------+-------+---------+'
  echo -e  "| Group    | 040  |  020  |   010   |" 
  echo -e  '+----------+------+-------+---------+'
  echo -e  "| Everyone | 004  |  002  |   001   |" 
  echo -e  '+----------+------+-------+---------+'
}


######################
# checking arguments #
######################
  #
  #
if [[ -z $1 ]]; then
  #
  # runs when no argument is passed
  print_help
  #
elif [ $1 -eq $1 2>/dev/null ]; then
##################################
# runs when argument is a number #
##################################
  #
  # Arguments are not mutable,
  # so we create var that holds
  # value of the first argument.
  arg=$1
  #
  # User may input number with dash
  # at the beginning, if it's the
  # case, then we cut the dash here.
  [ $arg -lt 0 ] &&
    arg=$(echo $arg | cut -b2-)
  #
  # Valid numeric notation is 3 digits
  # long. If argument is shorter, then
  # it's invalid.
  [ ${#arg} = 3 ]   &&
    draw_table $arg ||
    print_help "Invalid Numeric Notation: \"$1\"
    Number must be 3 digits long"
  #
  #
elif [[ ${#1} = 9 ]]; then
  #
  # runs when lenght of argument is 9 (lenght of symbolic notation)
  draw_table $1 1
  #
else
  #
  # runs when argument doesnt mach any of above
  check_options $1
  #
fi
